// Generated by zig-wayland

// Copyright © 2008-2013 Kristian Høgsberg
// Copyright © 2013      Rafael Antognolli
// Copyright © 2013      Jasper St. Pierre
// Copyright © 2010-2013 Intel Corporation
// Copyright © 2015-2017 Samsung Electronics Co., Ltd
// Copyright © 2015-2017 Red Hat Inc.
// 
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice (including the next
// paragraph) shall be included in all copies or substantial portions of the
// Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
// 

const std = @import("std");
const os = std.os;
const client = @import("wayland.zig").client;
const common = @import("common.zig");pub const WmBase = opaque {
 pub const generated_version = 2;
 pub const getInterface = common.xdg.wm_base.getInterface;pub const Error = common.xdg.wm_base.Error;
pub fn setQueue(_wm_base: *WmBase, _queue: *client.wl.EventQueue) void {
    const _proxy = @ptrCast(*client.wl.Proxy, _wm_base);
    _proxy.setQueue(_queue);
}pub const Event = union(enum) {ping: struct {serial:u32,},
};
pub inline fn setListener(
    _wm_base: *WmBase,
    comptime T: type,
    _listener: *const fn (wm_base: *WmBase, event: Event, data: T) void,
    _data: T,
) void {
    const _proxy = @ptrCast(*client.wl.Proxy, _wm_base);
    const _mut_data = @intToPtr(?*anyopaque, @ptrToInt(_data));
    _proxy.addDispatcher(common.Dispatcher(WmBase, T).dispatcher, _listener, _mut_data);
}pub fn destroy(_wm_base: *WmBase) void {const _proxy = @ptrCast(*client.wl.Proxy,_wm_base);_proxy.marshal(0, null);_proxy.destroy();}
pub fn createPositioner(_wm_base: *WmBase) !*client.xdg.Positioner{const _proxy = @ptrCast(*client.wl.Proxy,_wm_base);var _args = [_]common.Argument{.{ .o = null },};
return @ptrCast(*client.xdg.Positioner, try _proxy.marshalConstructor(1, &_args, client.xdg.Positioner.getInterface()));}
pub fn getXdgSurface(_wm_base: *WmBase, _surface:*client.wl.Surface) !*client.xdg.Surface{const _proxy = @ptrCast(*client.wl.Proxy,_wm_base);var _args = [_]common.Argument{.{ .o = null },.{ .o = @ptrCast(*common.Object, _surface) },};
return @ptrCast(*client.xdg.Surface, try _proxy.marshalConstructor(2, &_args, client.xdg.Surface.getInterface()));}
pub fn pong(_wm_base: *WmBase, _serial:u32) void {const _proxy = @ptrCast(*client.wl.Proxy,_wm_base);var _args = [_]common.Argument{.{ .u = _serial},};
_proxy.marshal(3, &_args);}
};
pub const Positioner = opaque {
 pub const generated_version = 2;
 pub const getInterface = common.xdg.positioner.getInterface;pub const Error = common.xdg.positioner.Error;
pub const Anchor = common.xdg.positioner.Anchor;
pub const Gravity = common.xdg.positioner.Gravity;
pub const ConstraintAdjustment = common.xdg.positioner.ConstraintAdjustment;
pub fn setQueue(_positioner: *Positioner, _queue: *client.wl.EventQueue) void {
    const _proxy = @ptrCast(*client.wl.Proxy, _positioner);
    _proxy.setQueue(_queue);
}pub fn destroy(_positioner: *Positioner) void {const _proxy = @ptrCast(*client.wl.Proxy,_positioner);_proxy.marshal(0, null);_proxy.destroy();}
pub fn setSize(_positioner: *Positioner, _width:i32, _height:i32) void {const _proxy = @ptrCast(*client.wl.Proxy,_positioner);var _args = [_]common.Argument{.{ .i = _width},.{ .i = _height},};
_proxy.marshal(1, &_args);}
pub fn setAnchorRect(_positioner: *Positioner, _x:i32, _y:i32, _width:i32, _height:i32) void {const _proxy = @ptrCast(*client.wl.Proxy,_positioner);var _args = [_]common.Argument{.{ .i = _x},.{ .i = _y},.{ .i = _width},.{ .i = _height},};
_proxy.marshal(2, &_args);}
pub fn setAnchor(_positioner: *Positioner, _anchor:Anchor) void {const _proxy = @ptrCast(*client.wl.Proxy,_positioner);var _args = [_]common.Argument{.{ .u = switch (@typeInfo(Anchor )) {
    .Enum => @intCast(u32, @enumToInt(_anchor)),
    .Struct => @bitCast(u32, _anchor),
    else => unreachable,
 }},};
_proxy.marshal(3, &_args);}
pub fn setGravity(_positioner: *Positioner, _gravity:Gravity) void {const _proxy = @ptrCast(*client.wl.Proxy,_positioner);var _args = [_]common.Argument{.{ .u = switch (@typeInfo(Gravity )) {
    .Enum => @intCast(u32, @enumToInt(_gravity)),
    .Struct => @bitCast(u32, _gravity),
    else => unreachable,
 }},};
_proxy.marshal(4, &_args);}
pub fn setConstraintAdjustment(_positioner: *Positioner, _constraint_adjustment:u32) void {const _proxy = @ptrCast(*client.wl.Proxy,_positioner);var _args = [_]common.Argument{.{ .u = _constraint_adjustment},};
_proxy.marshal(5, &_args);}
pub fn setOffset(_positioner: *Positioner, _x:i32, _y:i32) void {const _proxy = @ptrCast(*client.wl.Proxy,_positioner);var _args = [_]common.Argument{.{ .i = _x},.{ .i = _y},};
_proxy.marshal(6, &_args);}
};
pub const Surface = opaque {
 pub const generated_version = 2;
 pub const getInterface = common.xdg.surface.getInterface;pub const Error = common.xdg.surface.Error;
pub fn setQueue(_surface: *Surface, _queue: *client.wl.EventQueue) void {
    const _proxy = @ptrCast(*client.wl.Proxy, _surface);
    _proxy.setQueue(_queue);
}pub const Event = union(enum) {configure: struct {serial:u32,},
};
pub inline fn setListener(
    _surface: *Surface,
    comptime T: type,
    _listener: *const fn (surface: *Surface, event: Event, data: T) void,
    _data: T,
) void {
    const _proxy = @ptrCast(*client.wl.Proxy, _surface);
    const _mut_data = @intToPtr(?*anyopaque, @ptrToInt(_data));
    _proxy.addDispatcher(common.Dispatcher(Surface, T).dispatcher, _listener, _mut_data);
}pub fn destroy(_surface: *Surface) void {const _proxy = @ptrCast(*client.wl.Proxy,_surface);_proxy.marshal(0, null);_proxy.destroy();}
pub fn getToplevel(_surface: *Surface) !*client.xdg.Toplevel{const _proxy = @ptrCast(*client.wl.Proxy,_surface);var _args = [_]common.Argument{.{ .o = null },};
return @ptrCast(*client.xdg.Toplevel, try _proxy.marshalConstructor(1, &_args, client.xdg.Toplevel.getInterface()));}
pub fn getPopup(_surface: *Surface, _parent:?*client.xdg.Surface, _positioner:*client.xdg.Positioner) !*client.xdg.Popup{const _proxy = @ptrCast(*client.wl.Proxy,_surface);var _args = [_]common.Argument{.{ .o = null },.{ .o = @ptrCast(?*common.Object, _parent) },.{ .o = @ptrCast(*common.Object, _positioner) },};
return @ptrCast(*client.xdg.Popup, try _proxy.marshalConstructor(2, &_args, client.xdg.Popup.getInterface()));}
pub fn setWindowGeometry(_surface: *Surface, _x:i32, _y:i32, _width:i32, _height:i32) void {const _proxy = @ptrCast(*client.wl.Proxy,_surface);var _args = [_]common.Argument{.{ .i = _x},.{ .i = _y},.{ .i = _width},.{ .i = _height},};
_proxy.marshal(3, &_args);}
pub fn ackConfigure(_surface: *Surface, _serial:u32) void {const _proxy = @ptrCast(*client.wl.Proxy,_surface);var _args = [_]common.Argument{.{ .u = _serial},};
_proxy.marshal(4, &_args);}
};
pub const Toplevel = opaque {
 pub const generated_version = 2;
 pub const getInterface = common.xdg.toplevel.getInterface;pub const Error = common.xdg.toplevel.Error;
pub const ResizeEdge = common.xdg.toplevel.ResizeEdge;
pub const State = common.xdg.toplevel.State;
pub fn setQueue(_toplevel: *Toplevel, _queue: *client.wl.EventQueue) void {
    const _proxy = @ptrCast(*client.wl.Proxy, _toplevel);
    _proxy.setQueue(_queue);
}pub const Event = union(enum) {configure: struct {width:i32,height:i32,states:*common.Array,},
close: void,};
pub inline fn setListener(
    _toplevel: *Toplevel,
    comptime T: type,
    _listener: *const fn (toplevel: *Toplevel, event: Event, data: T) void,
    _data: T,
) void {
    const _proxy = @ptrCast(*client.wl.Proxy, _toplevel);
    const _mut_data = @intToPtr(?*anyopaque, @ptrToInt(_data));
    _proxy.addDispatcher(common.Dispatcher(Toplevel, T).dispatcher, _listener, _mut_data);
}pub fn destroy(_toplevel: *Toplevel) void {const _proxy = @ptrCast(*client.wl.Proxy,_toplevel);_proxy.marshal(0, null);_proxy.destroy();}
pub fn setParent(_toplevel: *Toplevel, _parent:?*client.xdg.Toplevel) void {const _proxy = @ptrCast(*client.wl.Proxy,_toplevel);var _args = [_]common.Argument{.{ .o = @ptrCast(?*common.Object, _parent) },};
_proxy.marshal(1, &_args);}
pub fn setTitle(_toplevel: *Toplevel, _title:[*:0]const u8) void {const _proxy = @ptrCast(*client.wl.Proxy,_toplevel);var _args = [_]common.Argument{.{ .s = _title},};
_proxy.marshal(2, &_args);}
pub fn setAppId(_toplevel: *Toplevel, _app_id:[*:0]const u8) void {const _proxy = @ptrCast(*client.wl.Proxy,_toplevel);var _args = [_]common.Argument{.{ .s = _app_id},};
_proxy.marshal(3, &_args);}
pub fn showWindowMenu(_toplevel: *Toplevel, _seat:*client.wl.Seat, _serial:u32, _x:i32, _y:i32) void {const _proxy = @ptrCast(*client.wl.Proxy,_toplevel);var _args = [_]common.Argument{.{ .o = @ptrCast(*common.Object, _seat) },.{ .u = _serial},.{ .i = _x},.{ .i = _y},};
_proxy.marshal(4, &_args);}
pub fn move(_toplevel: *Toplevel, _seat:*client.wl.Seat, _serial:u32) void {const _proxy = @ptrCast(*client.wl.Proxy,_toplevel);var _args = [_]common.Argument{.{ .o = @ptrCast(*common.Object, _seat) },.{ .u = _serial},};
_proxy.marshal(5, &_args);}
pub fn resize(_toplevel: *Toplevel, _seat:*client.wl.Seat, _serial:u32, _edges:ResizeEdge) void {const _proxy = @ptrCast(*client.wl.Proxy,_toplevel);var _args = [_]common.Argument{.{ .o = @ptrCast(*common.Object, _seat) },.{ .u = _serial},.{ .u = switch (@typeInfo(ResizeEdge )) {
    .Enum => @intCast(u32, @enumToInt(_edges)),
    .Struct => @bitCast(u32, _edges),
    else => unreachable,
 }},};
_proxy.marshal(6, &_args);}
pub fn setMaxSize(_toplevel: *Toplevel, _width:i32, _height:i32) void {const _proxy = @ptrCast(*client.wl.Proxy,_toplevel);var _args = [_]common.Argument{.{ .i = _width},.{ .i = _height},};
_proxy.marshal(7, &_args);}
pub fn setMinSize(_toplevel: *Toplevel, _width:i32, _height:i32) void {const _proxy = @ptrCast(*client.wl.Proxy,_toplevel);var _args = [_]common.Argument{.{ .i = _width},.{ .i = _height},};
_proxy.marshal(8, &_args);}
pub fn setMaximized(_toplevel: *Toplevel) void {const _proxy = @ptrCast(*client.wl.Proxy,_toplevel);_proxy.marshal(9, null);}
pub fn unsetMaximized(_toplevel: *Toplevel) void {const _proxy = @ptrCast(*client.wl.Proxy,_toplevel);_proxy.marshal(10, null);}
pub fn setFullscreen(_toplevel: *Toplevel, _output:?*client.wl.Output) void {const _proxy = @ptrCast(*client.wl.Proxy,_toplevel);var _args = [_]common.Argument{.{ .o = @ptrCast(?*common.Object, _output) },};
_proxy.marshal(11, &_args);}
pub fn unsetFullscreen(_toplevel: *Toplevel) void {const _proxy = @ptrCast(*client.wl.Proxy,_toplevel);_proxy.marshal(12, null);}
pub fn setMinimized(_toplevel: *Toplevel) void {const _proxy = @ptrCast(*client.wl.Proxy,_toplevel);_proxy.marshal(13, null);}
};
pub const Popup = opaque {
 pub const generated_version = 2;
 pub const getInterface = common.xdg.popup.getInterface;pub const Error = common.xdg.popup.Error;
pub fn setQueue(_popup: *Popup, _queue: *client.wl.EventQueue) void {
    const _proxy = @ptrCast(*client.wl.Proxy, _popup);
    _proxy.setQueue(_queue);
}pub const Event = union(enum) {configure: struct {x:i32,y:i32,width:i32,height:i32,},
popup_done: void,};
pub inline fn setListener(
    _popup: *Popup,
    comptime T: type,
    _listener: *const fn (popup: *Popup, event: Event, data: T) void,
    _data: T,
) void {
    const _proxy = @ptrCast(*client.wl.Proxy, _popup);
    const _mut_data = @intToPtr(?*anyopaque, @ptrToInt(_data));
    _proxy.addDispatcher(common.Dispatcher(Popup, T).dispatcher, _listener, _mut_data);
}pub fn destroy(_popup: *Popup) void {const _proxy = @ptrCast(*client.wl.Proxy,_popup);_proxy.marshal(0, null);_proxy.destroy();}
pub fn grab(_popup: *Popup, _seat:*client.wl.Seat, _serial:u32) void {const _proxy = @ptrCast(*client.wl.Proxy,_popup);var _args = [_]common.Argument{.{ .o = @ptrCast(*common.Object, _seat) },.{ .u = _serial},};
_proxy.marshal(1, &_args);}
};
